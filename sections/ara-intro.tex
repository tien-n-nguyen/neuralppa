\section{Introduction}
Integrating the utilization of program analysis (PA) tools early in the development process of modern, large-scale software systems is crucial in determining the weaknesses/vulnerabilities in the code. Consider, for instance, a scenario in which a developer wants to use an online question and answering (Q\&A) forum, e.g., StackOverflow (S/O), to learn how to use software libraries or frameworks. Typically, the answer to a posed question comes as a fragment/chunk of code, which later makes it to the production application, stemming from the copy-and-paste software reuse practice. Unfortunately, if the copied code fragment is vulnerable, i.e., possesses defects that one can potentially exploit, it will result in the application being prone to attacks. Verdi {\em et al.}~\cite{verdi-tse22}
reviewed more than 72K C++ code snippets that migrated from 1,325 S/O answers, reporting a total of 99 vulnerable code snippets of 31 different types that made their way to 2,589 GitHub repositories.

Security researchers have proposed several automated approaches for
vulnerability detection using~program
analysis \cite{FlawFinder,RATS,viega2000its4,Checkmarx,HPFortify,Coverity,BufferOverFlow,SQLInj,Cross-siteScripting,AuthBypassSpoofing},
as well as machine learning (ML) and deep learning
(DL)~\cite{fse21,chakraborty2020deep,zhou2019devign,li2018sysevr,li2018vuldeepecker}
techniques. They leverage program representations such as
abstract syntax tree (AST), program dependence graph
(PDG)~\cite{fse21,li2018vuldeepecker}, control-flow graph
(CFG)~\cite{zhou2019devign}, data-flow graph
(DFG)~\cite{zhou2019devign}, code property graph
(CPG)~\cite{chakraborty2020deep}, etc., resulting from precise
automated analysis of software. However, extending such analyses to
code snippets is not straightforward as they are often incomplete,
unparseable, contain declaration/reference ambiguity, and are
interspersed between user comments. Currently, there exist tools such
as PPA~\cite{ppa08}, which parse an incomplete code fragment to build
the AST and extract data types in a best-effort manner, while
StaType~\cite{icse18} resolves the libraries and recovers only the
fully-qualified names for references.~However, the basic supports for
partial program analysis, i.e., for analyzing incomplete code are not
yet available.
%Such an infrastructure must include fundamental supports/services at the structural, semantic, and execution levels, thus enabling the static and dynamic analysis techniques to be built upon. 
%Let us refer to this as \textit{partial program analysis infrastructure}.

In addition to vulnerability detection, such an 
%partial program analysis infrastructure 
infrastructure
is also beneficial to other software engineering (SE) tasks that can tolerate a low level of errors and imprecision in building program representations. For example, consider code completion~\cite{codefill-icse22,facebook-icse21}, in which a model provides suggestions to complete partial code. Existing state-of-the-art ML/DL-based code completion models are just based on the code sequences or utilize the syntactic structure in ASTs, but none leverage the program dependencies due to the nature of partial code. Next, consider the task of analyzing the code fragments in a bug report to connect it to the relevant source files for bug localization purposes~\cite{euler-fse19,icpc17}. Here too, a need for partial program analysis, specifically partial program dependence analysis, can be observed.

The other facets of program analysis tools that need to be considered are their soundness and completeness. For example, static analysis tools are designed to detect errors that are valid for all possible executions, which often come at the cost of multiple approximations. As a result, such tools tend to overestimate, resulting in false positives. Next, consider the task of symbolic execution, which is limited by the path explosion problem that hinders its applicability to large-scale software systems. The effectiveness of such a symbolic execution engine can be improved by enhancing the symbolic constraints of the variables, and by guiding it to explore the right subset of symbolic states. 

%While the state-of-the-art research and practice has been well-established for the analysis of the entire programs, very little research and knowledge has been achieved for partial program analysis. 
To this effect, we set out to investigate and develop {\tool}, a {\em \underline{Neural} Network-Based \underline{P}rogram \underline{A}nalysis} infrastructure. We aim to establish {\bf a scientific foundation, novel methodologies, frameworks, models, and algorithmic solutions for neural program analysis}. {\tool} addresses two major issues in existing PA tools: (a) enables analysis of incomplete code fragments, i.e., partial program analysis; (b) empowers existing PA tools by making them more sound and complete (Figure~\ref{fig:arch}). {\tool} will allow the construction of efficient program analysis techniques for (partial) code on which downstream software engineering applications can be built.

\subsection{Research Objectives}

\subsection{Methodology and Anticipated Results}


\subsection{Preliminary Work}


\subsection{Intellectual Merits}


